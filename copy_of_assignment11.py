# -*- coding: utf-8 -*-
"""Copy of Assignment11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jGQ45A3DmYeCS74nmNgFeELt_jU5I2W-

# CS 498: Fundamentals of Computer Science I
## Assignment #11

**Due:** Friday, Dec. 11th by 11:59pm Central Time

**Total points:** 100 points of fun. :-)

# **Please complete course evaluations.**

If you haven't done so already, please take a few moments to complete the course evaluation. Your experience and feedback is very valuable. Plus, you could win a $25 Amazon gift card! :-)

Please visit https://go.illinois.edu/ices-online to complete the ICES questionnaire.

# 1 The Guessing Game 

Suppose the computer randomly selects a secret number from 1 to 100.  Your goal is to guess the secret number using as few guesses as possible. After your guess, the computer will give you feedback on how your guess relates to the secret number.
	
* If you guess too high, the computer prints **Too high.**  
	
* If you guess too low, the computer prints **Too low.**

## 1.1 An example.

```
Welcome to the Guessing Game!
=============================

Enter a guess: 87
Too high.

Enter a guess: 70
Too low.

Enter a guess: 80
Too low.

Enter a guess: 83

Congratulations! 
You guessed that 83 was the secret number.
It took you 4 guesses.
```
*Explanation of output.*  

* A welcome message is printed (lines 1-2).

* A prompt enter a guess is provided and the user enters `87` (line 4). The computer responds that the guess is Too high (line 5). 

* Since the secret number was not guessed, the user is prompted to enter another guess and enters `70` (line 7). The computers responds Too low (line 8). 

* Again, since the secret number was not guessed, the user is prompted for a guess and enters `80` (lines 10). The computer responds Too low (line 11). 

* The user gets another prompt for the secret number since it has not been guessed. At the prompt for a guess, the user enters `83` (line 13). At this point, the user has guessed the secret number and a congratulations message, the secret number, and the number of guesses are printed (15-17).

## 1.2 Your Code
"""

import random

def play_game(secret_num):
    """ 
    Plays the Guessing Game by having the user guess
    the secret number.
    
    Parameters:
       secret_num (int): the number to guess
           
    Returns:
          None
    """  

    # Add code for play_game function.
    print('=============================\n')

    guess = int(input('Enter a guess: '))

    count = 0

    while guess != secret_num:
      if guess > secret_num:
        count += 1
        print('Too high.\n')
        guess = int(input('Enter a guess: '))
      elif guess < secret_num:
        count += 1
        print('Too low.\n')
        guess = int(input('Enter a guess: '))
      
    if guess == secret_num:
        count += 1
        print('\nCongratulations!')
        print('You guessed that', guess, 'was the secret number.')
        print('It took you', count, 'guesses.')


def main():
    print('Welcome to the Guessing Game!')
    play_game(random.randint(1,100))

"""## 1.3 Testing Your Code

Discuss how you tested your code for the Guessing Game.

To test the code, I ran the function and played the game myself. Then, I checked to see if the number of guesses displayed was correct and if the spacing between lines was correct as well. I also checked to see if it would ever get the right answer and then display the right text.

# 2 Binary Search

Binary search is the algorithm we used to play the Guessing Game efficiently. 

The Binary search algorithm is based on the assumption that the items to be search are in sorted order.

The algorithm searches a sorted array by repeatedly dividing the search interval in half. 
* The algorithm begins with an interval covering the whole array.

* If the value of the search key is less than the itme in the middle of the interval, then the algorithm narrows the interval to the lower half. Otherwise, it narrows the interval to the upper half.

* Repeatedly perform the above step until the value is found or the interval is empty.

**Note:** Your binary search algorithm must be iterative and use a while loop.

## 2.1 Your Code
"""

def binary_search(item_list, key):
    """ 
    Executes the binary search algorithm. 
    Returns True if the key is in the list along
    with the index of where the key can be found.
    Otherwise, returns False and the index is -1
    denoted that the key is not in the list.

    The binary search algorithm operates iteratively.
    
    Parameters:
       item_list (list): a collection of items in a list
       key (any type): the key to find in the list
           
    Returns:
        bool: True if the key is found in the list.
              Otherwise, returns False.

        int: The position (or index) of the key in item_list. 
             If the key is not in the list, the 
             value of pos is -1.

    Examples:
         binary_search([19, 52, 100],  0) returns (False, -1)
         binary_search([-19, -2, 0, 1, 8, 13.4, 17, 32, 42], 32) returns (True, 7)
    """ 

    end = len(item_list) - 1
    number = 0
    start = 0    

    while start <= end :
      number = (end + start) // 2
      
      if item_list[number] < key:
        start = number + 1
      elif item_list[number] > key:
          end = number - 1
      else:
        return True, number

    return False, -1

"""## 2.2 Test Your Code"""

assert binary_search([-19, -2, 0], 32) == (False, -1)
assert binary_search([-19, -2, 0], 0) == (True, 2)
assert binary_search([-9, 21, 34, 65, 111, 588], 21) == (True, 1)

print('Right')

"""# 3 Reverse Guessing Game

You will write a different version of the Guessing Game, where the user thinks of a number between 1 and 100 and the computer tries to guess it.

* The computer tells the user its guess, and the user must tell the computer whether the guess is too high, too low, or correct.

* If the guess is correct, the computer congratulates itself, and the game ends. If the guess is too high or too low, the computer guesses again.

**Note:** The computer must use binary search to guess the user's secret number. You can think of binary search as the computer's artifical intelligence (AI) for guessing a secret number efficiently.

## 3.1 An Example

```
Welcome to the Reverse Guessing Game 
====================================

Think of a number from 1 to 1000.  
The computer will try to guess it.

Computer Guess #1: 500  
too (h)igh, too (l)ow, or (c)orrect? h

Computer Guess #2: 250  
too (h)igh, too (l)ow, or (c)orrect? h

Computer Guess #3: 125   
too (h)igh, too (l)ow, or (c)orrect? l

Computer Guess #4: 187  
too (h)igh, too (l)ow, or (c)orrect? h

Computer Guess #5: 156  
too (h)igh, too (l)ow, or (c)orrect? h

Computer Guess #6: 140  
too (h)igh, too (l)ow, or (c)orrect? h

Computer Guess #7: 132  
too (h)igh, too (l)ow, or (c)orrect? l

Computer Guess #8: 136
too (h)igh, too (l)ow, or (c)orrect? h

Computer Guess #9: 134  
too (h)igh, too (l)ow, or (c)orrect? h

Computer Guess #10: 133  
too (h)igh, too (l)ow, or (c)orrect? c

Congratulations to me!!
I am the greatest guesser in the WORLD!
```

*Explanation of output.*  

*  A welcome message and instructions are printed (lines 1-5).

* The computer guesses the value `500` (line 7). An input prompt of `too (h)igh, too (l)ow, or (c)orrect?` is printed, and the user types `h` and presses the Enter/Return key (line 8).

* The computer guesses the value `250` (line 10). An input prompt of `too (h)igh, too (l)ow, or (c)orrect?` is printed, and the user types `h` and presses the Enter/Return key (line 11).

* The computer guesses and the user responds with `h`, `l`, or `c` until the computer guesses correctly (lines 13-35)

* Once the computer guesses the secret number, a congratulations message is printed (lines 37-38).

## 3.2 Write Your Code

Your code must following good programming practices (e.g., well-documented, readable, consist of user-defined functions) that we have discussed throughout this course.
"""

def reverse_guessing():
  """
  Operates the reverse guessing game by using an iterative binary search method to guess the number.
  The user thinks of a number then plays the game by inputing whether the guess is too high, low, or correct.
  The computer then continues to guess or returns a statement if it is correct.

  Returns: string that includes guess then question, and prompts user for input
  """

  print('Welcome to the Reverse Guessing Game\n====================================\n')


  lowest = 1
  highest = 1000 - 1
  number = 0
  count = 1


  guess = (lowest + highest) // 2                         #attempts a first guess
  print('Computer guess #' + str(count), ':', guess)
  reply = input('too (h)igh, too (l)ow, or (c)orrect? ')    #returns guess and prompts user for input


  while reply != 'c':

    if reply == 'h':
      count += 1
      highest = guess - 1
      guess = (lowest + highest) // 2         #using binary search, make another guess if it is too high, and repeat the process
      print('\nComputer guess #' + str(count), ':', guess)
      reply = input('too (h)igh, too (l)ow, or (c)orrect? ')
    elif reply == 'l':
      count += 1
      lowest = guess + 1
      guess = (lowest + highest) // 2        #using binary search, make another guess if it is too low, and repeat process
      print('\nComputer guess #' + str(count), ':', guess)
      reply = input('too (h)igh, too (l)ow, or (c)orrect? ')
  
  if reply == 'c':
    print('\nCongratulations to me!!\nI am the greatest guesser in the WORLD!')    #prints this if guess is correct

"""## 3.3 Test Your Code

Discuss how you tested your code for the Reverse Guessing Game.

To test the code, I played the game myself while thinking of a number and made sure that the game ran properly, with the computer printing the correct lines based on the input and with the correct spacing between lines.

#4 Reading Code

One of the secrets of becoming a great Python programmer is to read, understand, and comprehend excellent code. Excellent code typically follows the guidelines outlined in [Code Style](https://https://docs.python-guide.org/writing/style/#code-style), and does its best to express a clear and concise intent to the reader.

Reading code is an important programming skill for the following reasons.
* Learning the syntax of the language elements in a classroom setting is not enough to learn how these
elements are used. You need to see the language in use in order to understand how those elements can
be applied in practice.
* Reading someone else’s code will help you appreciate how the structure of the program and its documentation affect its readability. You should make sure that when you write code it is as easy as
possible to read.
* Most software is developed by more than one programmer, which means that programmers working
on the team need to read each others’ code.
* In order to understand code you will sometimes need to learn elements of the language that you are
not familiar with. No programming course will ever teach you everything that there is to know about
a programming language. You should know where and how to look up things that you do not know
about. Reading code extends your knowledge of the language.

## 4.1 Requirements of Code Reading Assessment 

Consider the code in the Python modules (`random`, `turtle`, and `numpy`) modules. 

* `random`: Generates random numbers.
    * https://github.com/python/cpython/blob/master/Lib/random.py
* `turtle`: Provides Turtle Graphics.
https://github.com/python/cpython/blob/master/Lib/turtle.py
* `numpy`: Supports large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on arrays.
    * All source code: https://github.com/numpy/numpy/tree/master/numpy
    * Core functionality: https://github.com/numpy/numpy/tree/master/numpy/core

**Pick 1-2 of the above Python modules and give a 400-800 word assessment of the code.** When reading the code, consider the following questions.
* Is the code well written? 
* Is it easy to understand what it is doing? 
* Is it confusing?
* Did you learn anything new?

In your assessment, include code examples of exemplary code and explain why it is excellent code. If there are bad aspects to the code, then feel free to comment on that as well.

**Note:** You may not be able to feel like you understand a lot of the code. That's ok. But, even if you feel that way, you have enough knowledge regarding what good code looks like. That's the main objective of this code reading assignment.

## 4.2: Your Code Reading Assessment

The first thing I noticed about the code for the Turtle Graphics was the notes at the beginning, which gave a clear, concise summary of the purpose of the program and an example of how it works. The notes then continue to give a rundown of how they built the code and how they have improved on past versions of it. An extensive, clear list of new features is added. 
	
  Overall I thought the code written to run the function was very well written, which made it quite readable and organized. The import functions, for example, were well separated, and some lists then followed. It made sense to include the lists here but I would have liked some explanation of what these lists were and what they would be used for. The length of them also made it hard to follow. The CFG dictionary, on the other hand, was well written as element was on a new line and there were notes to annotate what was what.

I think that the mark of great code is if there is clearly defined, organized, functions for each different part of the overall program, and this code had just that. 

'''def __methodDict(cls, _dict):
    '''helper function for Scrolled Canvas'''
    baseList = list(cls.__bases__)
    baseList.reverse()
    for _super in baseList:
        __methodDict(_super, _dict)
    for key, value in cls.__dict__.items():
        if type(value) == types.FunctionType:
            _dict[key] = value'''

This was such a function that I believe really show how exemplary the code is. It starts with a clear note of what the function does. Then, a variable is clearly established. Then two for loops follow, each short and precise, with a clear goal to return for each. There is no redundancy in the code and nothing is repeated, no space wasted like I would have done.
	
  One of the other functions clearly states that there are many changes as a note. Although the code is extremely long and I barely understood what was going I never saw any function that was redundant, that went on for more than a dozen lines (with some exceptions), and in fact most of them were about five lines long. Every single one of them was annotated with a clear summary and the different parts of each were separated with empty lines which made everything easy to read.

I thought the program to generate random numbers was similarly well written. The notes written at the beginning were even better than the other program’s, with different notes separated out in different sections. The notes for each different function I also thought were more extensive and even clearer than those for the turtle function. The drawback for me was that some of the functions, such as the sample one, were very long and included several different if statements, and loops, and some within other ones, which definitely made it more difficult to follow along.

However I did find that some of the functions included were particularly elegant. The vonmisesvariate function, for example, had nearly a dozen lines of notes and the code for it was incredibly well organized, with each part grouped into two or three clear lines, separated by empty lines, and all the steps of the calculations for each variable were well written and clearly spaced out. The rest of the functions that ran calculations for variables were similarly very clearly written, separated out, organized, and easy to follow.

# CONGRATULATIONS YOU ARE DONE! :-)
"""